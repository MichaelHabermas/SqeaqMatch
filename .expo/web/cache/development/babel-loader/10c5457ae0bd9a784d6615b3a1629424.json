{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _jsxFileName = \"/Users/Habermoose/Desktop/speaq_rn/speaq_match/app/components/GameCard.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useRef } from \"react\";\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport Pressable from \"react-native-web/dist/exports/Pressable\";\nimport Image from \"react-native-web/dist/exports/Image\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport TouchableOpacity from \"react-native-web/dist/exports/TouchableOpacity\";\nimport { connect } from \"react-redux\";\nimport cardFront from \"../assets/cards/card_front.png\";\nimport cardBack from \"../assets/cards/card_back.png\";\n\nfunction GameCard(_ref) {\n  var card = _ref.card,\n      handleCardTap = _ref.handleCardTap,\n      languageToLearn = _ref.languageToLearn,\n      _ref$inStreak = _ref.inStreak,\n      inStreak = _ref$inStreak === void 0 ? false : _ref$inStreak;\n  var flipAnimation = useRef(new Animated.Value(0)).current;\n  var flipRotation = 0;\n  flipAnimation.addListener(function (_ref2) {\n    var value = _ref2.value;\n    return flipRotation = value;\n  });\n  var flipToFrontStyle = {\n    transform: [{\n      rotateY: flipAnimation.interpolate({\n        inputRange: [0, 180],\n        outputRange: [\"0deg\", \"180deg\"]\n      })\n    }]\n  };\n  var flipToBackStyle = {\n    transform: [{\n      rotateY: flipAnimation.interpolate({\n        inputRange: [0, 180],\n        outputRange: [\"180deg\", \"360deg\"]\n      })\n    }]\n  };\n\n  var flipToFront = function flipToFront() {\n    Animated.timing(flipAnimation, {\n      toValue: 180,\n      duration: 300,\n      useNativeDriver: true\n    }).start();\n  };\n\n  var flipToBack = function flipToBack() {\n    Animated.timing(flipAnimation, {\n      toValue: 0,\n      duration: 300,\n      useNativeDriver: true\n    }).start();\n  };\n\n  return React.createElement(Pressable, {\n    style: styles.container,\n    onPress: function onPress() {\n      return !!flipRotation ? flipToBack() : flipToFront();\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 61,\n      columnNumber: 3\n    }\n  }, React.createElement(Animated.Image, {\n    style: _objectSpread(_objectSpread({}, styles.card), flipToBackStyle),\n    source: cardFront,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 81,\n      columnNumber: 4\n    }\n  }), React.createElement(Animated.Image, {\n    style: _objectSpread(_objectSpread({}, styles.card), flipToFrontStyle),\n    source: cardBack,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 85,\n      columnNumber: 4\n    }\n  }));\n}\n\nvar styles = StyleSheet.create({\n  container: {\n    height: \"25%\",\n    paddingHorizontal: 1,\n    shadowColor: \"#000\",\n    shadowOffset: {\n      width: 2,\n      height: 2\n    },\n    shadowOpacity: 0.2,\n    shadowRadius: 3,\n    width: \"33%\"\n  },\n  card: {\n    height: \"100%\",\n    position: \"absolute\",\n    resizeMode: \"contain\",\n    width: \"100%\"\n  }\n});\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    languageToLearn: state.matchAndMemory.gameSettings.languageToLearn\n  };\n};\n\nexport default connect(mapStateToProps)(GameCard);","map":{"version":3,"sources":["/Users/Habermoose/Desktop/speaq_rn/speaq_match/app/components/GameCard.js"],"names":["React","useRef","connect","cardFront","cardBack","GameCard","card","handleCardTap","languageToLearn","inStreak","flipAnimation","Animated","Value","current","flipRotation","addListener","value","flipToFrontStyle","transform","rotateY","interpolate","inputRange","outputRange","flipToBackStyle","flipToFront","timing","toValue","duration","useNativeDriver","start","flipToBack","styles","container","StyleSheet","create","height","paddingHorizontal","shadowColor","shadowOffset","width","shadowOpacity","shadowRadius","position","resizeMode","mapStateToProps","state","matchAndMemory","gameSettings"],"mappings":"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","sourcesContent":["import React, { useRef } from \"react\";\nimport {\n\tAnimated,\n\tPressable,\n\tImage,\n\tStyleSheet,\n\tTouchableOpacity,\n} from \"react-native\";\n\n// redux\nimport { connect } from \"react-redux\";\n\nimport cardFront from \"../assets/cards/card_front.png\";\nimport cardBack from \"../assets/cards/card_back.png\";\n\nfunction GameCard({ card, handleCardTap, languageToLearn, inStreak = false }) {\n\tconst flipAnimation = useRef(new Animated.Value(0)).current;\n\n\tlet flipRotation = 0;\n\tflipAnimation.addListener(({ value }) => (flipRotation = value));\n\n\tconst flipToFrontStyle = {\n\t\ttransform: [\n\t\t\t{\n\t\t\t\trotateY: flipAnimation.interpolate({\n\t\t\t\t\tinputRange: [0, 180],\n\t\t\t\t\toutputRange: [\"0deg\", \"180deg\"],\n\t\t\t\t}),\n\t\t\t},\n\t\t],\n\t};\n\n\tconst flipToBackStyle = {\n\t\ttransform: [\n\t\t\t{\n\t\t\t\trotateY: flipAnimation.interpolate({\n\t\t\t\t\tinputRange: [0, 180],\n\t\t\t\t\toutputRange: [\"180deg\", \"360deg\"],\n\t\t\t\t}),\n\t\t\t},\n\t\t],\n\t};\n\n\tconst flipToFront = () => {\n\t\tAnimated.timing(flipAnimation, {\n\t\t\ttoValue: 180,\n\t\t\tduration: 300,\n\t\t\tuseNativeDriver: true,\n\t\t}).start();\n\t};\n\n\tconst flipToBack = () => {\n\t\tAnimated.timing(flipAnimation, {\n\t\t\ttoValue: 0,\n\t\t\tduration: 300,\n\t\t\tuseNativeDriver: true,\n\t\t}).start();\n\t};\n\n\treturn (\n\t\t<Pressable\n\t\t\t// \tonPress={() => handleCardTap(card.languages[languageToLearn])}\n\t\t\t// \tstyle={styles.container}\n\t\t\t// >\n\t\t\t// \t<Image\n\t\t\t// \t\tstyle={styles.card}\n\t\t\t// \t\tsource={require(\"../assets/cards/card_front.png\")}\n\t\t\t// \t/>\n\t\t\t// \t{inStreak ? (\n\t\t\t// \t\t<Image\n\t\t\t// \t\t\tstyle={styles.card}\n\t\t\t// \t\t\tsource={require(\"../assets/cards/card_back.png\")}\n\t\t\t// \t\t/>\n\t\t\t// \t) : (\n\t\t\t// \t\t<Image style={styles.card} source={card.image} />\n\t\t\t// \t)}\n\n\t\t\tstyle={styles.container}\n\t\t\tonPress={() => (!!flipRotation ? flipToBack() : flipToFront())}\n\t\t>\n\t\t\t<Animated.Image\n\t\t\t\tstyle={{ ...styles.card, ...flipToBackStyle }}\n\t\t\t\tsource={cardFront}\n\t\t\t/>\n\t\t\t<Animated.Image\n\t\t\t\tstyle={{ ...styles.card, ...flipToFrontStyle }}\n\t\t\t\tsource={cardBack}\n\t\t\t/>\n\t\t</Pressable>\n\t);\n}\n\nconst styles = StyleSheet.create({\n\tcontainer: {\n\t\theight: \"25%\",\n\t\tpaddingHorizontal: 1,\n\t\tshadowColor: \"#000\",\n\t\tshadowOffset: {\n\t\t\twidth: 2,\n\t\t\theight: 2,\n\t\t},\n\t\tshadowOpacity: 0.2,\n\t\tshadowRadius: 3,\n\t\twidth: \"33%\",\n\t},\n\tcard: {\n\t\theight: \"100%\",\n\t\tposition: \"absolute\",\n\t\tresizeMode: \"contain\",\n\t\twidth: \"100%\",\n\t},\n});\n\nconst mapStateToProps = state => ({\n\tlanguageToLearn: state.matchAndMemory.gameSettings.languageToLearn,\n});\n\nexport default connect(mapStateToProps)(GameCard);\n"]},"metadata":{},"sourceType":"module"}