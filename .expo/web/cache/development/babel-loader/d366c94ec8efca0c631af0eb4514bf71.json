{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nvar _jsxFileName = \"/Users/Habermoose/Desktop/speaq_rn/speaq_match/app/screens/GamePlayScreen.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nimport React, { useEffect, useState } from \"react\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport { connect } from \"react-redux\";\nimport CardsContainer from \"../components/CardsContainer\";\nimport Screen from \"../components/Screen\";\nimport ScreenHeader from \"../components/ScreenHeader\";\nimport SpeechBubble from \"../components/SpeechBubble\";\nimport StreakTracker from \"../components/StreakTracker\";\nimport { deckShuffle } from \"../gameLogic\";\nimport { characters, decks, levels } from \"../test_data\";\nvar deckIndecies = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\nfunction GamePlayScreen(_ref) {\n  var currentDeckName = _ref.currentDeckName,\n      currentLevel = _ref.currentLevel,\n      languageToLearn = _ref.languageToLearn,\n      navigation = _ref.navigation;\n\n  var _useState = useState(12),\n      _useState2 = _slicedToArray(_useState, 2),\n      streak = _useState2[0],\n      setStreak = _useState2[1];\n\n  var _useState3 = useState(characters[2]),\n      _useState4 = _slicedToArray(_useState3, 2),\n      speaker = _useState4[0],\n      setSpeaker = _useState4[1];\n\n  var _useState5 = useState(decks[currentDeckName].deck),\n      _useState6 = _slicedToArray(_useState5, 2),\n      currentDeck = _useState6[0],\n      setCurrentDeck = _useState6[1];\n\n  var _useState7 = useState({\n    cardText: \"\",\n    unchosen: deckIndecies,\n    currentCardIdx: Math.floor(Math.random() * 12)\n  }),\n      _useState8 = _slicedToArray(_useState7, 2),\n      currentCardText = _useState8[0],\n      setCurrentCardText = _useState8[1];\n\n  var preText = levels[currentLevel].languages[languageToLearn].pre;\n  var postText = levels[currentLevel].languages[languageToLearn].post;\n  useEffect(function () {\n    resetStreak();\n  }, []);\n\n  var handleNavButtonTap = function handleNavButtonTap(screen) {\n    if (streak > 0) navigation.navigate(screen);\n  };\n\n  var idxRandomizer = function idxRandomizer(length) {\n    return Math.floor(Math.random() * length);\n  };\n\n  var resetStreak = function resetStreak() {\n    var randomCardIdx = deckIndecies[idxRandomizer(12)];\n    setCurrentCardText({\n      cardText: currentDeck[randomCardIdx].languages[languageToLearn],\n      unchosen: deckIndecies.filter(function (num) {\n        return num != randomCardIdx;\n      })\n    });\n    setCurrentDeck(deckShuffle(currentDeck));\n    setStreak(12);\n  };\n\n  var handleCardTap = function handleCardTap(cardText) {\n    if (streak <= 0) return;\n\n    if (cardText === currentCardText.cardText) {\n      if (streak <= 1) {\n        handleGameOver();\n      } else {\n        var randomCardIdx = currentCardText.unchosen[idxRandomizer(currentCardText.unchosen.length)];\n        setCurrentCardText(_objectSpread(_objectSpread({}, currentCardText), {}, {\n          cardText: decks[currentDeckName].deck[randomCardIdx].languages[languageToLearn],\n          unchosen: currentCardText.unchosen.filter(function (num) {\n            return num != randomCardIdx;\n          })\n        }));\n        setStreak(streak - 1);\n        setSpeaker(characters[idxRandomizer(characters.length)]);\n      }\n    } else {\n      resetStreak();\n    }\n  };\n\n  var handleGameOver = function handleGameOver() {\n    setStreak(streak - 1);\n    setTimeout(function () {\n      navigation.navigate(\"GameOver\");\n      resetStreak();\n    }, 1000);\n  };\n\n  if (!characters || !decks || !levels) {\n    return React.createElement(View, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 105,\n        columnNumber: 4\n      }\n    }, React.createElement(Text, {\n      __self: this,\n      __source: {\n        fileName: _jsxFileName,\n        lineNumber: 106,\n        columnNumber: 5\n      }\n    }, \"Loading...\"));\n  }\n\n  return React.createElement(Screen, {\n    style: styles.screen,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 3\n    }\n  }, React.createElement(ScreenHeader, {\n    navLeft: function navLeft() {\n      return handleNavButtonTap(\"Options\");\n    },\n    navLeftIcon: require(\"../assets/buttons/options_icon_light.png\"),\n    navRight: function navRight() {\n      return handleNavButtonTap(\"Help\");\n    },\n    navRightIcon: require(\"../assets/buttons/help_icon_light.png\"),\n    showTitle: false,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 113,\n      columnNumber: 4\n    }\n  }), React.createElement(StreakTracker, {\n    streak: streak,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 121,\n      columnNumber: 4\n    }\n  }), React.createElement(CardsContainer, {\n    handleCardTap: handleCardTap,\n    deck: currentDeck,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 123,\n      columnNumber: 4\n    }\n  }), React.createElement(SpeechBubble, {\n    character: speaker,\n    text: \"\" + preText + currentCardText.cardText + postText,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 4\n    }\n  }));\n}\n\nvar styles = StyleSheet.create({});\n\nvar mapStateToProps = function mapStateToProps(state) {\n  return {\n    currentDeckName: state.matchAndMemory.gameSettings.currentDeckName,\n    currentLevel: state.matchAndMemory.gameSettings.currentLevel,\n    languageToLearn: state.matchAndMemory.gameSettings.languageToLearn\n  };\n};\n\nexport default connect(mapStateToProps)(GamePlayScreen);","map":{"version":3,"sources":["/Users/Habermoose/Desktop/speaq_rn/speaq_match/app/screens/GamePlayScreen.js"],"names":["React","useEffect","useState","connect","CardsContainer","Screen","ScreenHeader","SpeechBubble","StreakTracker","deckShuffle","characters","decks","levels","deckIndecies","GamePlayScreen","currentDeckName","currentLevel","languageToLearn","navigation","streak","setStreak","speaker","setSpeaker","deck","currentDeck","setCurrentDeck","cardText","unchosen","currentCardIdx","Math","floor","random","currentCardText","setCurrentCardText","preText","languages","pre","postText","post","resetStreak","handleNavButtonTap","screen","navigate","idxRandomizer","length","randomCardIdx","filter","num","handleCardTap","handleGameOver","setTimeout","styles","require","StyleSheet","create","mapStateToProps","state","matchAndMemory","gameSettings"],"mappings":"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","sourcesContent":["import React, { useEffect, useState } from \"react\";\nimport { StyleSheet, View } from \"react-native\";\n\n// redux\nimport { connect } from \"react-redux\";\n\n// components\nimport CardsContainer from \"../components/CardsContainer\";\nimport Screen from \"../components/Screen\";\nimport ScreenHeader from \"../components/ScreenHeader\";\nimport SpeechBubble from \"../components/SpeechBubble\";\nimport StreakTracker from \"../components/StreakTracker\";\n\n// logic\nimport { deckShuffle } from \"../gameLogic\";\n\n// TODO: get this from the server/dynamically\nimport { characters, decks, levels } from \"../test_data\";\nconst deckIndecies = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];\n\nfunction GamePlayScreen({\n\tcurrentDeckName,\n\tcurrentLevel,\n\tlanguageToLearn,\n\tnavigation,\n}) {\n\tconst [streak, setStreak] = useState(12);\n\tconst [speaker, setSpeaker] = useState(characters[2]);\n\tconst [currentDeck, setCurrentDeck] = useState(decks[currentDeckName].deck);\n\tconst [currentCardText, setCurrentCardText] = useState({\n\t\tcardText: \"\",\n\t\tunchosen: deckIndecies,\n\t\tcurrentCardIdx: Math.floor(Math.random() * 12),\n\t});\n\n\tconst preText = levels[currentLevel].languages[languageToLearn].pre;\n\tconst postText = levels[currentLevel].languages[languageToLearn].post;\n\n\tuseEffect(() => {\n\t\tresetStreak();\n\t}, []);\n\n\tconst handleNavButtonTap = screen => {\n\t\tif (streak > 0) navigation.navigate(screen);\n\t};\n\n\tconst idxRandomizer = length => Math.floor(Math.random() * length);\n\n\tconst resetStreak = () => {\n\t\tconst randomCardIdx = deckIndecies[idxRandomizer(12)];\n\t\tsetCurrentCardText({\n\t\t\tcardText: currentDeck[randomCardIdx].languages[languageToLearn],\n\t\t\tunchosen: deckIndecies.filter(num => num != randomCardIdx),\n\t\t});\n\t\tsetCurrentDeck(deckShuffle(currentDeck));\n\t\tsetStreak(12);\n\t};\n\n\tconst handleCardTap = cardText => {\n\t\t// prevent over-selecting cards on game over\n\t\tif (streak <= 0) return;\n\t\tif (cardText === currentCardText.cardText) {\n\t\t\t// game over condition\n\t\t\tif (streak <= 1) {\n\t\t\t\t// setStreak(streak - 1);\n\t\t\t\t// setTimeout(() => {\n\t\t\t\t// \tnavigation.navigate(\"GameOver\");\n\t\t\t\t// \tresetStreak();\n\t\t\t\t// }, 1000);\n\t\t\t\thandleGameOver();\n\t\t\t} else {\n\t\t\t\tconst randomCardIdx =\n\t\t\t\t\tcurrentCardText.unchosen[\n\t\t\t\t\t\tidxRandomizer(currentCardText.unchosen.length)\n\t\t\t\t\t];\n\t\t\t\tsetCurrentCardText({\n\t\t\t\t\t...currentCardText,\n\t\t\t\t\tcardText:\n\t\t\t\t\t\tdecks[currentDeckName].deck[randomCardIdx].languages[\n\t\t\t\t\t\t\tlanguageToLearn\n\t\t\t\t\t\t],\n\t\t\t\t\tunchosen: currentCardText.unchosen.filter(\n\t\t\t\t\t\tnum => num != randomCardIdx\n\t\t\t\t\t),\n\t\t\t\t});\n\t\t\t\tsetStreak(streak - 1);\n\t\t\t\tsetSpeaker(characters[idxRandomizer(characters.length)]);\n\t\t\t}\n\t\t} else {\n\t\t\tresetStreak();\n\t\t}\n\t};\n\n\tconst handleGameOver = () => {\n\t\tsetStreak(streak - 1);\n\t\tsetTimeout(() => {\n\t\t\tnavigation.navigate(\"GameOver\");\n\t\t\tresetStreak();\n\t\t}, 1000);\n\t};\n\n\t// TODO: need a better loading mechanism\n\tif (!characters || !decks || !levels) {\n\t\treturn (\n\t\t\t<View>\n\t\t\t\t<Text>Loading...</Text>\n\t\t\t</View>\n\t\t);\n\t}\n\n\treturn (\n\t\t<Screen style={styles.screen}>\n\t\t\t<ScreenHeader\n\t\t\t\tnavLeft={() => handleNavButtonTap(\"Options\")}\n\t\t\t\tnavLeftIcon={require(\"../assets/buttons/options_icon_light.png\")}\n\t\t\t\tnavRight={() => handleNavButtonTap(\"Help\")}\n\t\t\t\tnavRightIcon={require(\"../assets/buttons/help_icon_light.png\")}\n\t\t\t\tshowTitle={false}\n\t\t\t/>\n\n\t\t\t<StreakTracker streak={streak} />\n\n\t\t\t<CardsContainer\n\t\t\t\thandleCardTap={handleCardTap}\n\t\t\t\tdeck={currentDeck}\n\t\t\t\t// inStreak={inStreak}\n\t\t\t/>\n\n\t\t\t<SpeechBubble\n\t\t\t\tcharacter={speaker}\n\t\t\t\ttext={`${preText}${currentCardText.cardText}${postText}`}\n\t\t\t/>\n\t\t</Screen>\n\t);\n}\n\nconst styles = StyleSheet.create({});\n\nconst mapStateToProps = state => ({\n\tcurrentDeckName: state.matchAndMemory.gameSettings.currentDeckName,\n\tcurrentLevel: state.matchAndMemory.gameSettings.currentLevel,\n\tlanguageToLearn: state.matchAndMemory.gameSettings.languageToLearn,\n});\n\nexport default connect(mapStateToProps)(GamePlayScreen);\n"]},"metadata":{},"sourceType":"module"}